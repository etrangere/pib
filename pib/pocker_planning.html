<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script>
        const prefix = window.location.pathname.replace(/\/{2,}/g, '/');
        const currentPath = window.location.pathname.replace(/\/{2,}/g, '/');
        const baseUrl = `http://localhost${currentPath}`;
        //alert(baseUrl); 
      </script>
    <title>Pocker Planning</title>
</head>
<header>Pocker Planning</header>
<body>

    <div id="textarea-container"> 
        <label for="Pocker Planning">Validate</label><input id="PockerPlanning" type="checkbox" ><label for="Pocker Planning">Ignore</label><input id="PockerPlanning" type="checkbox" >Pocker Planning
    </div>

    <p>Le planning poker est une façon ludique de produire des estimations sur l'effort de développement de fonctionnalités. Cette pratique est surtout utilisée en informatique, en eXtreme Programming (XP), en Scrum et dans les méthodes agiles en général pour évaluer les scénarios utilisateurs (user stories) du carnet de produit (product backlog). La méthode a été décrite pour la première fois par James Grenning1,2 en 2002 et popularisée par Mike Cohn dans le livre Agile Estimating and Planning3.

        Utilisation
        L'avantage principal du planning poker est de permettre à tous de s'exprimer librement. L'estimation serait meilleure parce que plusieurs personnes l'auront validée4 : des participants avec des niveaux d'expérience et d'expertise différents. De plus, cette technique favorise les échanges entre le responsable de produits et l'équipe de développement.
        
        L'estimation se fait en unités d'œuvre intitulées points de récits ou "journées idéales" (Ideal Day).
        
        Les points de récits permettent d'obtenir une véritable mesure relative de l'effort : les scénarios sont comparés entre eux. L'équivalent en jours-hommes est propre à chacun, selon ses compétences, son expérience et sa connaissance du domaine. L'avantage d'utiliser des points réside surtout dans le fait que l'échelle utilisée restera stable tout au long du projet. Peu importe la vitesse (vélocité) à laquelle l'équipe de développement accomplira ces tâches, nul besoin de réviser les estimations : c'est le rapport entre le temps réel et les points qui évoluera.
        
        Les avantages de l'estimation en "journées idéales" (ou heures idéale en cas de fine granularité des tâches) sont parfaitement identiques à ceux des points de récits. Par contre, l'estimation en journées idéales est plus aisée à concrétiser dans l'esprit des acteurs qui sont généralement plus à l'aise avec la notion de "journée" qu'avec un "point de récit" de taille variable pour chaque projet, qui peut aussi bien représenter quelques heures que quelques jours, et qui devra devenir une unité de référence.</p>
        <div><label for="step4">Step 4:</label>
            <input type="checkbox" id="step4" name="step4" onchange="updateProgressBar()"></div>
    </body>
</html>
<script>
    const textareaContainer = document.getElementById("textarea-container");
    const textareas = textareaContainer.getElementsByTagName("textarea");
    const checkboxes = textareaContainer.querySelectorAll("input[type='checkbox']");
    
    let formValues = {};
    
    let counter = 0; // initialize counter variable
    
    for (let i = 0; i < textareas.length + checkboxes.length; i++) {
      if (i < textareas.length) {
        const textarea = textareas[i];
        const id = prefix + (counter + 1);
        textarea.id = id;
        formValues[id] = textarea.value;
        textarea.addEventListener("input", (event) => {
          formValues[id] = event.target.value;
          localStorage.setItem("formValues", JSON.stringify(formValues));
        });
        counter++; // increment counter variable
      } else {
        const checkbox = checkboxes[i - textareas.length];
        const id = prefix + (counter + 1);
        checkbox.id = id;
        formValues[id] = checkbox.checked;
        checkbox.addEventListener("change", (event) => {
          formValues[id] = event.target.checked;
          localStorage.setItem("formValues", JSON.stringify(formValues));
        });
        counter++; // increment counter variable
      }
    }
    
    const savedFormValues = localStorage.getItem("formValues");
    
    if (savedFormValues) {
      formValues = JSON.parse(savedFormValues);
      for (const id in formValues) {
        if (formValues.hasOwnProperty(id)) {
          const element = document.getElementById(id);
          if (element) {
            if (element.tagName === "TEXTAREA") {
              element.value = formValues[id];
            } else if (element.tagName === "INPUT" && element.type === "checkbox") {
              element.checked = formValues[id];
            }
          } else {
            console.warn(`Element with id "${id}" not found on page`);
          }
        }
      }
    }
    
    const updateButton = document.getElementById("update-button-all");
    updateButton.addEventListener("click", () => {
      for (let i = 0; i < textareas.length + checkboxes.length; i++) {
        const id = prefix + (i + 1);
        const element = document.getElementById(id);
        if (element) {
          if (element.tagName === "TEXTAREA") {
            formValues[id] = element.value;
          } else if (element.tagName === "INPUT" && element.type === "checkbox") {
            formValues[id] = element.checked;
          }
        } else {
          console.warn(`Element with id "${id}" not found on page`);
        }
      }
      localStorage.setItem("formValues", JSON.stringify(formValues));
      alert("Values updated!");
    });
    
    </script>